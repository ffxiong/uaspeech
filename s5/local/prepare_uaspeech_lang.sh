#!/bin/bash

# author: Feifei Xiong @ SPandH Sheffield

# prepare the language model for UASPEECH data
# The parts of the output of this that will be needed are
# [in data/dict/ ]
# lexicon.txt
# extra_questions.txt
# nonsilence_phones.txt
# optional_silence.txt
# silence_phones.txt
# G.fst 

# Begin configuration section
cleanup=true
lm_order=1
# End configuration section

. ./utils/parse_options.sh  # accept options.. you can run this run.sh with the

. ./path.sh

echo >&2 "$0" "$@"
if [ $# -ne 2 ] ; then
  echo >&2 "$0" "$@"
  echo >&2 "$0: Error: wrong number of arguments"
  echo -e >&2 "Usage:\n  $0 [opts] <flist-dir> <output-dir>"
  echo -e >&2 "eg:\n  $0 flist data"
  exit 1
fi

set -e -o pipefail

fdir=$1
ddir=$2

dict_dir=$ddir/dict
mkdir -p $dict_dir

# check files
[ ! -f $fdir/word.dict ] && echo "prepare datat: no such file $f" && exit 1;

# pronunciations 
word_dict=$fdir/word.dict
tr '[:lower:]' '[:upper:]' < $word_dict > $dict_dir/uaspeech.dict

# Dictionary preparation:
# Make phones symbol-table (adding in silence and verbal and non-verbal noises at this point).
# We are adding suffixes _B, _E, _S for beginning, ending, and singleton phones.

# silence phones, one per line.
echo SIL > $dict_dir/silence_phones.txt
echo SIL > $dict_dir/optional_silence.txt

# obtain list of phones
grep -vi SIL $dict_dir/uaspeech.dict | \
perl -e 'while(<>){
  next if /^#/;
  my @e=split;
  for (@e[1..$#e]) { $p{$_}=1; }
}
print join("\n", map { uc } sort keys %p), "\n"'  \
> $dict_dir/nonsilence_phones.txt || exit 1;

# A few extra questions that will be added to those obtained by automatically clustering
# the "real" phones.  These ask about stress; there's also one for silence.
cat $dict_dir/silence_phones.txt | awk '{printf("%s ", $1);} END{printf "\n";}' > $dict_dir/extra_questions.txt || exit 1;
cat $dict_dir/nonsilence_phones.txt | perl -e 'while(<>){ foreach $p (split(" ", $_)) {
  $p =~ m:^([^\d]+)(\d*)$: || die "Bad phone $_"; $q{$2} .= "$p "; } } foreach $l (values %q) {print "$l\n";}' \
 >> $dict_dir/extra_questions.txt || exit 1;

grep -v "^#" $dict_dir/uaspeech.dict > $dict_dir/lexicon1_raw_nosil.txt

(echo '!SIL SIL'; echo '<SPOKEN_NOISE> SIL';) | \
 cat - $dict_dir/lexicon1_raw_nosil.txt  > $dict_dir/lexicon.txt || exit 1;

if [ -f $dict_dir/lexiconp.txt ]; then
   rm $dict_dir/lexiconp.txt
fi

echo " ... Dictionary preparation succeeded"


# Prepare wordlists, etc.
utils/prepare_lang.sh $dict_dir "<SPOKEN_NOISE>" $ddir/lang_tmp $ddir/lang || exit 1;

echo " ... Word Dictionary L.fst succeeded"


# Prepare language models for test
# create model
lang=$ddir/lang

# uni-gram, manually create the G.txt
Gfil=$fdir/G.txt
[ ! -f $Gfil ] && echo "prepare datat: no such file $f" && exit 1;
fstcompile --isymbols=$lang/words.txt --osymbols=$lang/words.txt --keep_isymbols=false \
    --keep_osymbols=false $Gfil | fstarcsort --sort_type=ilabel > $lang/G.fst || exit 1;

#Â uni-gram generated by srilm
#cut -d' ' -f1 $dict_dir/uaspeech.dict | uniq > $lang/corpus.txt
#ngram-count -order $lm_order -write-vocab $lang/vocab-full.txt -wbdiscount -text $lang/corpus.txt -lm $lang/lm.arpa
#arpa2fst --disambig-symbol=#0 --read-symbol-table=$lang/words.txt $lang/lm.arpa $lang/G.fst

fstisstochastic $lang/G.fst

# Everything below is only for diagnostic.
# Checking that G has no cycles with empty words on them (e.g. <s>, </s>);
# this might cause determinization failure of CLG.
# #0 is treated as an empty word.
awk '{if(NF==1){ printf("0 0 %s %s\n", $1,$1); }} END{print "0 0 #0 #0"; print "0";}' \
  < "$dict_dir/lexicon.txt"  >$ddir/lang_tmp/select_empty.fst.txt
fstcompile --isymbols=$lang/words.txt --osymbols=$lang/words.txt \
  $ddir/lang_tmp/select_empty.fst.txt | \
fstarcsort --sort_type=olabel | fstcompose - $lang/G.fst > $ddir/lang_tmp/empty_words.fst
fstinfo $ddir/lang_tmp/empty_words.fst | grep cyclic | grep -w 'y' &&
  echo "Language model has cycles with empty words" && exit 1


$cleanup && rm -rf $ddir/*tmp

echo "Succeeded in formatting LM in $lang"






